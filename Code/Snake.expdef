expdef:
name:Snake
info:~
This experiment definition can be used to perform a range
of common experiments. It provides

- one gene pool
- one population for individuals
- one "population" for food
- steady-state evolutionary optimization
- fitness as a weighted sum of performance values
- or custom fitness formulas
- fitness scaling
- selection: roulette or tournament
- multiple evaluation option, average and standard deviation available
- can produce logs with average and best fitness
- can detect stagnation and stop automatically
- can save best genotypes
~
code:~

global g_evaluated_genotype; //genotype uid for multiple evaluation mode
global g_bestsofar; //last best
global g_bestsofarnr; //last best time
global g_uniquename; //used to save experiment files

function onExpDefLoad()
{
	// define genotype and creature groups
	GenePools.clear();
	Populations.clear();
	GenePools[0].name = "Genotypes";
	update_fitformula();

	var p = Populations[0];
	p.name = "Creatures";
	p.nnsim = 1;
	p.enableperf = 1;
	p.death = 1;
	p.energy = 1;
	p.selfmask = 0x10001;
	p.othermask = 0x20001;

	p = Populations.addGroup("Food");
	p.nnsim = 0;
	p.enableperf = 0;
	p.death = 1;
	p.energy = 1;
	p.selfmask = 0x20002;
	p.othermask = 0x10002;

	ExpParams.initialgen = "X[Sin][-1:0.891, =:0.834][|-1:-1][|-2:1]X[|-2:1,!:01, s:0][|-2:1.588, !:.01]RX[|-2:1, !:.01][|-2:1, !:.01]X[|-2:1.669, !:.01][|-2:1.512, !:.01]RX[|-2:1, !:.01][|-2:-4.538, !:.01]X[|-1:2.485][|-3:1, 1:-5.351][|-3:1, !:0.102, -9:1]X[|-2:1, !:.01][|-2:3.348, !:.01]";
	ExpParams.capacity = 200;
	ExpParams.delrule = 0;
	ExpParams.MaxCreated = 1;
	ExpParams.p_nop = 20;
	ExpParams.p_mut = 64;
	ExpParams.p_xov = 16;
	ExpParams.xov_mins = 0;
	ExpParams.selrule = 2;
	ExpParams.cr_c = 0;
	ExpParams.cr_life = 0;
	ExpParams.cr_v = 1;
	ExpParams.cr_gl = 0;
	ExpParams.cr_joints = 0;
	ExpParams.cr_nnsiz = 0;
	ExpParams.cr_nncon = 0;
	ExpParams.cr_di = 0;
	ExpParams.cr_vpos = 0;
	ExpParams.cr_vvel = 0;
	ExpParams.cr_norm = 0;
	ExpParams.cr_simi = 0;
	ExpParams.Energy0 = 1000;
	ExpParams.e_meta = 1;
	ExpParams.feed = 10;
	ExpParams.feede0 = 200;
	ExpParams.feedtrans = 1;
	ExpParams.placement = 0;
	ExpParams.rotation = 0;
	ExpParams.creath = 0.1;
	ExpParams.foodgen = "";
	ExpState.totaltestedcr = 0;
	ExpState.totaltests = 0;

	ExpParams.minfitness = 0;
	g_bestsofarnr = -1;
	g_uniquename = "notinited";
}

function onExpInit()
{
	Populations[0].clear();
	Populations[1].clear();
	GenePools[0].clear();
	GenePools[0].add(ExpParams.initialgen);
	ExpState.totaltestedcr = 0;
	ExpState.totaltests = 0;

	g_evaluated_genotype = null;
	g_bestsofarnr = -1;
	g_uniquename = String.format("%06d", Math.time % 1000000) + String.format("%02d", (Math.time % 1) * 100);
	if (ExpParams.log > 0)
	{
		var unchanged;
		if (ExpParams.evalcount > 0)
			unchanged = "" + ExpParams.evalcount + "x ";
		else
			unchanged = "" + ExpParams.p_nop + ",";
		Simulator.print("[LOGTITLE] " + ["MECHA", "ODE"][World.simtype] + " rnd=(" +
		                sim_params.bnoise_struct + "," + sim_params.bnoise_vel + "," + sim_params.randinit +
		                ") popsize=" + ExpParams.capacity +
		                " gen.ops.=(" + unchanged + ExpParams.p_mut + "," + ExpParams.p_xov + ")");
	}
}

@include "standard_placement.inc"

function onBorn(cr)
{
	var TRIALS = 50; //try to find free place 50 times
	var retry = TRIALS;

	/* if you want to rotate a creature differently each time it is evaluated during "multiple evaluation"
	if (ExpParams.evalcount == 6)
	{
	  //different rotation in each of the multiple evaluations: none, left, right, forth, back, upside-down
	  var rotationsx = [0, 0,        0,         Math.pi2, -Math.pi2, 2.0*Math.pi2];
	  var rotationsy = [0, Math.pi2, -Math.pi2, 0,        0,         0];
	  var extrarotate = ExpState.totaltests % 6;
	  cr.rotate(rotationsx[extrarotate],rotationsy[extrarotate],0);
	}*/

	var placed_ok = 0;
	while (retry--)
	{
		var trycentral = (ExpParams.placement == 1) && (retry == TRIALS - 1); //place central only in the first trial
		placeCreatureRandomly(cr, trycentral, ExpParams.rotation);
		if (!cr.boundingBoxCollisions(0))
		{
			placed_ok = 1;
			break;
		}
	}
	if (!placed_ok)
		Simulator.message("onBorn() could not avoid collisions.", 1);

	if (cr.population.index == 0)
	{
		// creature
		var n = cr.numjoints;
		if (n == 0)
			n = cr.numparts; //creatures with only one Part will live just as long as one-stick creatures
		cr.idleen = ExpParams.e_meta * n;
		cr.energy0 = cr.energy0 * ExpParams.Energy0 * n;
		cr.energy = cr.energy0;
	}
	else
	{
		// food
		cr.name = "Food";
		cr.idleen = 0;
		cr.energy0 = ExpParams.feede0;
		cr.energy = cr.energy0;
	}
}

function addfood()
{
	if (ExpParams.foodgen == "")
		return Populations[1].add("//0\nm:Vstyle=food\np:");
	else
		return Populations[1].add(ExpParams.foodgen);
}

function onStep()
{
	if (Populations[0].size < ExpParams.MaxCreated)
	{
		if (GenePools[0].size == 0)
		{
			Simulator.stop();
			Simulator.message("This experiment is designed to build creatures from genotypes, but the GenePool is empty.", 2);
		}
		else
		{
			var g = selectGenotype();
			//Simulator.print("g="+g);
			if (g)
			{
				if (g.is_valid)
					Populations[0].add(g);
				else
					Simulator.message("invalid genotype - ignored: " + g.info, 1);
			}
			else
				Simulator.message("no genotype selected", 1);
		}
	}

	if (ExpParams.aging > 0)
	{
		for(var cr in Populations[0])
			cr.idleen = ExpParams.e_meta * cr.numjoints
			            * Math.exp((0.6931471806 * cr.lifespan) / ExpParams.aging);
	}

	if (Populations[1].size < ExpParams.feed)
		addfood();
}


function saveGenotype(genotype, filename, description, append)
{
	var f;
	if (append)
		f = File.appendDirect(filename, description);
	else
		f = File.createDirect(filename, description);
	f.writeNameObject("org", genotype);
	f.close();
}



global g_eval_again; //just to detect if some genotype is evaluated once again (and how much its average fitness varies from evaluation to evaluation even when they are repeated)

// returns Genotype object that was updated or created from cr
function updatePerformanceWithPopSize(cr)
{
	var GROUP_IDENTICAL_GENOTYPES = 1; //do you want identical genotypes to be grouped as one Genotype object (with instances>1 and averaged performances)?
	var g = null;
	if (GROUP_IDENTICAL_GENOTYPES)
		g = GenePools[0].findGenotype(cr.geno); //will be either null (if no cr.geno exists in GenePools[0]) or some existing Genotype

	if (g == null) //cr.geno not found, which means that we have to add a new Genotype
	{
		g = Genotype.newFromCreature(cr);
		g.num = 0; // 0 = it will be filled automatically
		g.moveTo(GenePools[0]);
		g.instances = 0;
		g.user1 = g.user2 = g.user3 = null; //reset user fields so that they are not inherited
	}

	if (ExpParams.evalcount > 0) //multiple evaluation
	{
		if (typeof(g.user1) != "Vector") //first evaluation or other, rare cases (e.g. mutation produced an already existing genotype)
		{
			if (g.user1 != null) g_eval_again = g.fit2; //was already evaluated! let's see how much its average fitness varies
			g.user1 = Vector.new();
		}
		g.instances = g.user1.size;
	}

	// Want to copy customized values from Creature user fields to Genotype user fields? Do it here: g.user2 = cr.user2;
	// Want to take instances into account? Do it here: g.user2 = (float(g.user2) * g.instances + cr.user2) / (g.instances + 1);
	g.addPerformanceFromCreature(cr); //averages performances of "g" according to instances and increments instances

	//multiple evaluation - tricks to compute stddev of fitness and to detect if the same genotype has been multiply evaluated in the past:
	if (ExpParams.evalcount > 0)
	{
		if (g_evaluated_genotype != null && GenePools[0].findUID(g_evaluated_genotype) < 0)
			g_evaluated_genotype = null; //evaluated genotype was lost
		if (g_evaluated_genotype == null)
			g_evaluated_genotype = g.uid;
		g.user1.add(g.fit * g.instances - g.user1.avg * g.user1.size); //restore (and append to the user1 vector) original fitness from Genotype.fit's incremental average which is fit1, (fit1+fit2)/2, (fit1+fit2+fit3)/3, ...
		if (g.user1.size < ExpParams.evalcount)
		{
			g.instances = 0; //keep instances 0 ("has no fitness") until evaluated as many times as required
			ExpState.totaltestedcr--; //don't count individual evaluations, increment only after ExpParams.evalcount evaluations
		}
		else
		{
			g_evaluated_genotype = null; //no more evaluations needed for this one
			g.user1 = g.user1.stdev; //compute std.dev. for a vector of fitness values
			g.instances = 1;
			if (g_eval_again != null)
			{
				Simulator.print("Another multiple evaluation of '" + g.name + "': previous average fitness was " + g_eval_again + ", now changed by " + (g.fit2 - g_eval_again));
				g_eval_again = null;
			}
		}
	}

	//may be useful: save (append) all dying genotypes to a log file
	//if (ExpParams.evalcount == 0 || (ExpParams.evalcount > 0 && Genotype.instances == 1)) //no multiple evaluation: save all. multiple evaluation: save only when evaluation complete
	//  saveSelectedGenotype(g_uniquename + "_died.gen", "Those who died", 1);

	//extras:
	var improvement = GenePools[0].genotype_instances > 0 && (g_bestsofarnr == -1 || stats.st_max_fit2 > g_bestsofar);
	var logevery = [-1, 0, 1, 10, 100, 1000][ExpParams.log];
	var log = logevery == 0 && improvement; //either improved
	if (logevery > 0) //or periodic log
		if (ExpState.totaltestedcr % logevery == 0 || g_bestsofarnr == -1)
			log = 1; //always log the first step
	if (ExpParams.evalcount > 0 && (g_evaluated_genotype != null))
		log = 0; //avoid multiple logs on subsequent evaluations of the same genotype
	if (improvement)
	{
		var ratio; //bigger improvement -> higher and longer sound (max. 0.1 sec for >=2x improvement)
		if (g_bestsofarnr == -1 || g_bestsofar <= 0 || Math.abs(g_bestsofar) < 0.001)
			ratio = 0.01;
		else
			ratio = (stats.st_max_fit2 / g_bestsofar - 1) / 10;
		if (ratio < 0.01)
			ratio = 0.01;
		else if (ratio > 0.1)
			ratio = 0.1;
		if (ExpParams.makesound)
			Simulator.sound(2000.0 + 10000.0 * ratio, 1000.0 * ratio);
		g_bestsofar = stats.st_max_fit2;
		g_bestsofarnr = ExpState.totaltestedcr;
		if (ExpParams.savebest == 1)
			saveGenotype(g, g_uniquename + ".gen", "Improvement snapshot", 0);
		if (ExpParams.savebest == 2)
			saveGenotype(g, g_uniquename + ".gen", "Improvement snapshot", 1);
		if (ExpParams.savebest == 3)
			Simulator.save(g_uniquename + ".expt");
	}
	var stagnation = ExpParams.stagnation > 0 && g_bestsofar > ExpParams.minfitness && ExpState.totaltestedcr > g_bestsofarnr + ExpParams.stagnation;
	if (log || (logevery >= 0 && stagnation))
		Simulator.print("[LOG] " + ExpState.totaltestedcr + " " + GenePools[0].size + " " + stats.st_min_fit2 + " " + stats.st_avg_fit2 + " " + stats.st_max_fit2);
	if (stagnation) //ExpParams.stagnation of non-improving evaluations stops.
	{
		var mesg = "stagnation detected (" + ExpParams.stagnation + ") at " + ExpState.totaltestedcr + " evals, best fitness = " + g_bestsofar + ", ";
		if (ExpParams.boostphase && ExpParams.delrule != 2)
		{
			mesg += "starting boost phase.";
			ExpParams.delrule = 2;
			ExpParams.evalcount *= 2;
			g_bestsofarnr = ExpState.totaltestedcr; //start stagnation detection again
		}
		else
		{
			mesg += "stopping.";
			if (ExpParams.makesound)
				Simulator.sound(300, 200);
			Simulator.stop();
		}
		Simulator.print(mesg);
	}

	return g;
}

//returns Genotype object that was updated or created from cr (used by standard-background.expdef)
function onDied(cr)
{
	//Simulator.print("on died cr="+cr+" group="+cr.population.name+" ("+cr.population.index+")");
	var g = null;
	if (cr.population.index != 0)
		return null; // ignore food
	if (cr.lifespan > 0)
	{
		ExpState.totaltestedcr++;
		ExpState.totaltests++;
		g = updatePerformanceWithPopSize(cr);
	}
	else   //the creature was killed before stabilization
	{
		if (ExpParams.evalcount > 0) g_evaluated_genotype = null; //so don't try to evaluate it anymore. TODO seems that multiple evaluation mode does not handle this properly (this situation increases genotype count in group)
	}
	LimitGenePool();
	Simulator.checkpointData(ExpState.totaltestedcr);
	return g;
}

@include "standard_select.inc"

function selectGenotype() //returns Genotype object
{
	var sel, nop;
	if (ExpParams.evalcount > 0)
	{
		if (g_evaluated_genotype != null)
		{
			var gg = GenePools[0].findUID(g_evaluated_genotype);
			if (gg < 0)
				g_evaluated_genotype = null;
			else
			{
				if (GenePools[0][gg].user1.size < ExpParams.evalcount)
				{
					return GenePools[0][gg];
				}
			}
		}
		if (g_evaluated_genotype == null)
			nop = 0.0; //wanted a new mutation/xover to evaluate
	}
	else
		nop = ExpParams.p_nop;
	var sum = nop + ExpParams.p_mut + ExpParams.p_xov;
	sel = sum * Math.rnd01;
	//Simulator.print("sum="+sum+" sel="+sel+" nop="+nop+" mut="+ExpParams.p_mut+" xov="+ExpParams.p_mut);
	if (sel < nop || sum == 0)
	{
		//Simulator.print("selectGeno - nop");
		var selected = selectedForCreationInPool(GenePools[0]);
		if (selected)
			return selected;
		else
			return null;
	}
	else
	{
		sel = sel - nop;
		if (sel < ExpParams.p_mut)
		{
			// Simulator.print("selectGeno - mutate");
			var selected = selectedForCreationInPool(GenePools[0]);
			if (selected)
			{
				var g = Genotype.newFromGeno(GenMan.mutate(selected.geno));
				g.gnum = selected.gnum + 1; //generation
				return g;
			}
			else
				return null;
		}
		else
		{
			var other;
			var first = selectedForCreationInPool(GenePools[0]);
			if (ExpParams.xov_mins > 0.0)
				other = selectedSimilarInPool(GenePools[0]);
			else
				other = selectedForCreationInPool(GenePools[0]);
			// Simulator.print("selectGeno - xover - first="+first+" other="+other);
			if ((first != null) && (other != null))
			{
				var g = Genotype.newFromGeno(GenMan.crossOver(first.geno, other.geno));
				g.gnum = Math.max(first.gnum, other.gnum) + 1; //generation
				return g;
			}
			else
			{
				Simulator.print("crossover - second genotype not found?");
				return null;
			}
		}
	}
}

function onFoodCollision()
{
	var e = Collision.Part2.ing * ExpParams.feedtrans;
	//Simulator.print("transferring "+e+" from "+Collision.Creature1.name+" to "+Collision.Creature2.name);
	Collision.Creature1.energy_m = Collision.Creature1.energy_m + e;
	Collision.Creature2.energy_p = Collision.Creature2.energy_p + e;
}

function ExpParams_cleardata_call()
{
	for(var g in GenePools[0])
		g.instances = 0;
	Simulator.print("Performance data reset.");
}

function LimitGenePool()
{
	var pool = GenePools[0];
	if (pool.genotype_instances > (ExpParams.capacity + 1)) // if removing more than 1
		Simulator.print("Removing " + (pool.genotype_instances - ExpParams.capacity) + " genotype instances");
	while (pool.genotype_instances > ExpParams.capacity)
		selectedForDeletionInPool(pool).deleteOne();
}

function ExpParams_capacity_set()
{
	LimitGenePool();
}

function limitPopulation(pop, n)
{
	n = pop.size - n;
	while (n > 0)
	{
		pop.delete(pop.size - 1);
		n--;
	}
}

function ExpParams_MaxCreated_set()
{
	limitPopulation(Populations[0], ExpParams.MaxCreated); //creatures
}

function ExpParams_feed_set()
{
	limitPopulation(Populations[1], ExpParams.feed); //food
}

@include "standard_fitformula.inc"
@include "standard_events.inc"
@include "standard_loadsave.inc"

~

#include "standard_props.inc"
#include "standard_props_extras.inc"

prop:
id:cleardata
name:Clear performance info
type:p
help:~
Sets the number of instances of each genotype to zero (as if it has never been evaluated).
Genotype performance values stay intact, yet they are meaningless if a genotype has no instances.~

state:
id:notes
name:Notes
type:s 1
help:~
You can write anything here
(it will be saved to the experiment file)~

state:
id:totaltestedcr
name:Evaluated creatures
help:Total number of creatures evaluated in the experiment
type:d
flags:16

state:
id:totaltests
name:Number of evaluations
help:~
Total number of evaluations in the experiment.
This is equivalent to "Evaluated creatures" unless multiple evaluation is activated.~
type:d
flags:16

state:
id:creaturesgrouploaded
name:creaturesgrouploaded
type:d
flags:34

